Basic javascript Problems: 113


/******************************************************/
ES6 : 29

Spread operator:
	ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.
	
	apply() method
		var arr = [6, 89, 3, 45];
		var maximus = Math.max.apply(null, arr);  (OR)  
		
	Evaluate Arrays In-Place:
		const maximus = Math.max(...arr);
		function howMany(...args) {  return args.length; }
		
	NOTE: The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.
	
Destructuring Assignment:
	Destructuring assignment is special syntax introduced in ES6, for neatly assigning values taken directly from an object.
	
	Object:
		const user = { name: 'John Doe', age: 34 };
		const { name, age } = user;
	
	Function Parameter: 
		const profileUpdate = (profileData) => {  const { name, age, nationality, location } = profileData; }
		const profileUpdate = ({ name, age, nationality, location }) => { }
		
	Nested Objects: 
		const { johnDoe: { age: userAge, email: userEmail }} = user;
	Array: 
		const [a, b, ...c] = [1, 2, 3, 4, 5, 6];
	
	
String Interpolation:
	const greeting = `Hello, my name is ${person.name}! I am ${person.age} years old.`;

constructor
	Constructors are functions that create new objects. 
	They define properties and behaviors that will belong to the new object. Think of them as a blueprint for the creation of new objects.
	
	
	class Book {   //It should be noted that the class syntax is just syntax, and not a full-fledged class-based implementation of an Oops
	  constructor(author) {
		this._author = author;
	  }
	  // getter
	  get writer() {
		return this._author;
	  }
	  // setter
	  set writer(updatedAuthor) {
		this._author = updatedAuthor;
	  }
	}

module
	<script type="module" src="filename.js"></script>

Export
	const add = (a,b) => a+b;
	export { add };
	export { add,substract };
	export default function add(x, y) {  return x + y; }   //It is also used to create a fallback value for a file or module.

Import
	import add from "./functions.js";
	import * as func from "./functions.js";

promise
	const myPromise = new Promise((resolve, reject) => {
		if(condition here) {
			resolve("Promise was fulfilled");
		} else {
			reject("Promise was rejected");
		}
	});
	myPromise.then(result => {});
	myPromise.catch(error => {});

/******************************************************/
Regex: 33

	.test() method -->   if a pattern exists or not within a string   --> returns true/false
		Syntax:				/searchWord/.test(sentence)    
		case-sensitive: 	regex /Kevin/ will not match kevin or KEVIN
		ignore case:		/kevin/i
		OR Operator: 		/yes|no|maybe/
		
	.match() method -->  You can also extract the actual matches you found  --> returns first occurence by default 
							output: [ 'brown',  index: 10,  input: 'The quick brown fox jumps over the lazy dog.',  groups: undefined ]
			
		Syntax:				'string'.match(/regex/);   //NOTE: opposite of test() method
		global search:		'string'.match(/regex/gi); //returns all occurences in array --> output: [ 'brown', 'Brown' ]
		 
	WildCard characters:
		. 		--> one character
		+ 		--> multiple characters >= 1
		* 		--> multiple characters >= 0
		? 		--> turns greedy match to lazy match
		^ 		--> beginning of strings MOTE: [^] is neglected character set if it is used inside bracket 
		$ 		--> end of strings
		{2,5}	--> quantity specifiers: You can specify the lower and upper number of patterns  
					/ you can give without upper limit too as {2,}
					/ Specify Exact Number of Matches {2}
		()		--> grouping
		(?=...)	--> Lookahead (positive)
		(?!...)	-> Lookahead (negative)
		
	Expressions:
		/[aeiou}/gi 	--> search any one of the character in it
		/[a-z]/gi 		--> returns all alpha characters
		/[a-z0-9]/gi 	--> returns all alphanumeric characters
		/[^aeiou]/gi	--> the negated character set only excludes the vowel characters.
		/s+/gi			--> find matches when the letter s occurs one or more times
		/Aa*/gi			--> find matches when the letter A and a* occurs zero or more times
		/t[a-z]*i/		--> greedy match - return matching long possible characters
		/t[a-z]*?i/		--> lazy match	- return matching short possible characters
		/[A-Za-z0-9_]/g	--> Match All Letters and Numbers (longhand)
		/\w/g			--> Match All Letters and Numbers (shorthand)   \w = [A-Za-z0-9_]
		/\W/g			--> Neglect All matching Letters and Numbers	\W = [^A-Za-z0-9_]
		/\d/g			--> Match all digits							\d = [0-9]
		/\D/g			--> Match all Non-digits						\D = [^0-9]
		\s				--> whitespaces
		\S				--> Non-whitespaces
		/favou?rite/	--> Check for All or None (like optional)
		/^(/d+) \1 \1$/	--> Capture Groups  // captures exactly 3 values '42 42 42'
		
	Use Capture Groups to Search and Replace
		"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');  //$ symbol to capture groups
		
		Example:
		let str = "one two three";
		let fixRegex = /^(\w+)\s(\w+)\s(\w+)$/; // Change this line
		let replaceText = "$3 $2 $1"; // Change this line
		let result = str.replace(fixRegex, replaceText);
		
	Restrict Possible Usernames
		/^[a-z]([a-z]+\d*|[0-9]{2,})$/gi;

		Usernames can only use alpha-numeric characters.
		The only numbers in the username have to be at the end. There can be zero or more of them at the end. Username cannot start with the number.
		Username letters can be lowercase and uppercase.
		Usernames have to be at least two characters long. A two-character username can only use alphabet letters as characters.	
		
		
/******************************************************/
Debugging: 12

console.log();
console.clear();
console.log(typeof "");  //the console will display the strings string "", number 1, object [], and object {}.

/******************************************************/
Basic Data Structures: 20

splice(startpos, no.of.ele) 								- removes elements from array
splice(startpos, no.of.ele, newele1, new ele2, ...) 		- removes elements from array

slice(startpos, endPos) 									- copies elements from array
let thatArray = [...thisArray];								- copy an Array with the Spread Operator
let sentence = ['learning', ...fragment, 'is', 'fun'];		- combines array values using Spread Operator

arr.indexOf(ele);											- Index Of
for(let names in obj)  {    nameList.push(names); } 		- Get keys in an object


/******************************************************/
Basic Algorithm Scripting: 16

#Reverse a String:
function reverseString(str) {
  return str.split('').reverse().join('');
}

#Factorialize:
function factorialize(num) {
  if(num<2){
    return 1;
  }
  return num * factorialize(num-1);
}

#Find the Longest Word in a String:
function findLongestWordLength(str) {
  let words = str.split(" ")
  let maxLen = 0;
  for(let i=0; i<words.length;i++){
      if(words[i].length > maxLen){
        maxLen = words[i].length;
      }
  }
  return maxLen;
}

#Return Largest Numbers in Arrays
function largestOfFour(arr) {
  let res= [];
  for(let i=0;i<arr.length;i++)
  {
    res.push(NaN);
    let ele = arr[i];
    res[i]=Math.max(...ele);
  }
  console.log(res);
  return res;
}

#Confirm the Ending (.endsWith() - ES2015 approach)
function confirmEnding(str, target) {
  if(str.substr(-target.length) == target ){
    return true;
  }
  return false;
}

#Repeat a String Repeat a String
function repeatStringNumTimes(str, num) {
  let res = "";
  for (let i=0;i<num;i++){
    res += str;
  }
  return res;
}

#Truncate a String with a ... ending.
function truncateString(str, num) {
  if(num<str.length){
    return str.substr(0,num)+"...";
  }
  return str;
}

#Finders Keepers
function findElement(arr, func) {
  for(let i=0;i<arr.length;i++){
    if(func(arr[i])){
      return arr[i];
    }
  }
  return undefined;
}
findElement([1, 3], num => num % 2 === 0);

#Boo who - Check if a value is classified as a boolean primitive. Return true or false
function booWho(bool) {
  if(typeof bool === "boolean")
  {
    return true;
  }
  return false;
}

#Title Case a Sentence
function titleCase(str) {
  return str.toLowerCase().replace(/(^|\s)\S/g, firstLetter => firstLetter.toUpperCase());
}

#Slice and Splice
You are given two arrays and an index. Copy each element of the first array into the second array, in order.
Begin inserting elements at index n of the second array.
Return the resulting array. The input arrays should remain the same after the function runs.

function frankenSplice(arr1, arr2, n) {
  let newArr = arr2.slice(0,n);
  newArr.push(...arr1);
  newArr.push(...arr2.slice(n));
  console.log(newArr);
  return newArr;
}

#Falsy Bouncer
Remove all falsy values from an array. Falsy values in JavaScript are false, null, 0, "", undefined, and NaN.
Hint: Try converting each value to a Boolean.

function bouncer(arr) {
  //let falsyValues = [false, null, 0, "", undefined, NaN];
  let newArr = [];
  for(let i=0;i<arr.length;i++){
    if(arr[i]){
        newArr.push(arr[i]);
    }
  }
  return newArr;
}

#Where do I Belong
function getIndexToIns(arr, num) {
  arr.sort(function(a, b){return a-b});
  console.log(arr);
  for(let i=0;i<arr.length;i++){
    if(arr[i]>=num){
      return i;
    }
  }
  return arr.length;
}
(OR)
function getIndexToIns(arr, num) {
  return arr.filter(val => num > val).length;
}

#Mutations  - Return true if the string in the first element of the array contains all of the letters of the string in the second element of the array.
function mutation(arr) {
   return arr[1]
    .toLowerCase()
    .split("")
    .every(function(letter) {
      return arr[0].toLowerCase().indexOf(letter) !== -1;
    });
}

#Chunky Monkey -  Write a function that splits an array (first argument) into groups the length of size (second argument) and returns them as a two-dimensional array.
function chunkArrayInGroups(arr, size) {
  let newArr = [];
  while(arr.length>=size){
      newArr.push(arr.splice(0,size));
  }

  if(arr.length > 0){
    newArr.push(arr);
  }

  return newArr;
}

/******************************************************/
Projects

#Ascii
"S".charCodeAt(0); //Get ASCII Value
String.fromCharCode(65); //Get Char Value

/*
#Telephone Number Validator
Return true if the passed string looks like a valid US phone number.
The user may fill out the form field any way they choose as long as it has the format of a valid US number. The following are examples of valid formats for US numbers (refer to the tests below for other variants):

555-555-5555
(555)555-5555
(555) 555-5555
555 555 5555
5555555555
1 555 555 5555
For this challenge you will be presented with a string such as 800-692-7753 or 8oo-six427676;laskdjf. Your job is to validate or reject the US phone number based on any combination of the formats provided above. The area code is required. If the country code is provided, you must confirm that the country code is 1. Return true if the string is a valid US phone number; otherwise return false.
telephoneCheck("1 456 789 4444");*/

function telephoneCheck(str) {
  let regEx = /^(\d{3}-|\u0028\d{3}\u0029|1\s\d{3}-|1(\s\u0028\d{3}\u0029\s|\s\d{3}\s|\u0028\d{3}\u0029|\d{3}))\d{3}[-\s]\d{4}$|^\d{10}$/;
  return regEx.test(str);
}

/*****************************************/
OOPS: 26

let Bird = function(name, color) {   //constructor declaration (2 parameters and 1 property)
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black"); 

crow instanceof Bird; //return true